# This router will be mounted under /tenants/{tenant_name}/offers
import typing
from fastapi import APIRouter, Depends, HTTPException, status, Path
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.api.v1 import deps # For get_db, get_current_active_user, TenantRoleChecker, get_tenant_by_name

router = APIRouter()

# Define required roles for different offer operations
can_create_offer = deps.TenantRoleChecker(required_roles=["admin", "create"])
can_read_offer = deps.TenantRoleChecker(required_roles=["admin", "create", "approver", "read_only"])
can_update_offer_draft = deps.TenantRoleChecker(required_roles=["create"]) # If draft
can_update_offer_admin = deps.TenantRoleChecker(required_roles=["admin"]) # Broader update
can_delete_offer_admin = deps.TenantRoleChecker(required_roles=["admin"])
can_submit_offer = deps.TenantRoleChecker(required_roles=["admin", "create"])
can_approve_reject_offer = deps.TenantRoleChecker(required_roles=["admin", "approver"])
can_comment_offer = deps.TenantRoleChecker(required_roles=["admin", "create"]) # Or approver too

@router.post("/", response_model=schemas.Offer, status_code=status.HTTP_201_CREATED, dependencies=[Depends(can_create_offer)])
def create_offer(
    *,
    db: Session = Depends(deps.get_db),
    offer_in: schemas.OfferCreate,
    tenant: models.Tenant = Depends(deps.get_tenant_by_name), # Injected by path param {tenant_name}
    current_user: models.User = Depends(deps.get_current_active_user),
) -> typing.Any:
    """
    Create a new offer within the specified tenant.
    User must have 'admin' or 'create' role in the tenant.
    """
    # Enrich offer_in with tenant_name and created_by_username
    # The CRUDBase.create expects all fields required by the model.
    # Offer model requires tenant_name, created_by_username.
    # Create a full dict for model creation.
    offer_data = offer_in.model_dump()
    offer_data["tenant_name"] = tenant.name
    offer_data["created_by_username"] = current_user.username
    
    # We need a way to pass this enriched data to CRUDBase.create, or have a custom create in CRUDOffer.
    # For now, let's assume CRUDBase.create can handle it if OfferCreate includes these,
    # or we use a custom method in crud_offer.
    # A simple way:
    db_offer = models.Offer(**offer_data, status=models.OfferStatus.DRAFT) # Explicitly set default status
    db.add(db_offer)
    
    # Create audit log
    audit_log_in = schemas.OfferAuditLogCreate(
        offer_id=0, # Placeholder, will be set after offer commit
        action="create",
        new_data=offer_in.data,
        performed_by_username=current_user.username
    )
    # This needs careful handling of offer_id if it's autogenerated.
    # Best to create offer, then audit log.

    db.commit()
    db.refresh(db_offer)

    # Create audit log after offer is created and has an ID
    audit_log_in.offer_id = db_offer.id
    crud.offer_audit_log.create(db, obj_in=audit_log_in)

    return db_offer

@router.get("/", response_model=typing.List[schemas.Offer], dependencies=[Depends(can_read_offer)])
def list_offers(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    skip: int = 0,
    limit: int = 100,
    status_filter: typing.Optional[models.OfferStatus] = None, # Query param for status
    created_by_filter: typing.Optional[str] = None, # Query param for creator
    # current_user: models.User = Depends(deps.get_current_active_user), # Already handled by TenantRoleChecker
) -> typing.Any:
    """
    List offers for the tenant.
    """
    query = db.query(models.Offer).filter(models.Offer.tenant_name == tenant.name)
    if status_filter:
        query = query.filter(models.Offer.status == status_filter)
    if created_by_filter:
        query = query.filter(models.Offer.created_by_username == created_by_filter)
    
    offers = query.offset(skip).limit(limit).all()
    return offers

@router.get("/{offer_id}", response_model=schemas.Offer, dependencies=[Depends(can_read_offer)])
def get_offer(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    offer_id: int = Path(..., gt=0),
) -> typing.Any:
    """
    Get specific offer by ID.
    """
    offer = db.query(models.Offer).filter(
        models.Offer.id == offer_id,
        models.Offer.tenant_name == tenant.name
    ).first()
    
    if not offer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Offer with ID {offer_id} not found in tenant {tenant.name}"
        )
    
    return offer

@router.patch("/{offer_id}", response_model=schemas.Offer, dependencies=[Depends(can_update_offer_admin)])
def update_offer(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    offer_id: int = Path(..., gt=0),
    offer_in: schemas.OfferUpdate,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> typing.Any:
    """
    Update an offer.
    """
    offer = db.query(models.Offer).filter(
        models.Offer.id == offer_id,
        models.Offer.tenant_name == tenant.name
    ).first()
    
    if not offer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Offer with ID {offer_id} not found in tenant {tenant.name}"
        )
    
    # Store old data for audit log
    old_data = offer.data
    
    # Update the offer
    update_data = offer_in.model_dump(exclude_unset=True)
    
    for key, value in update_data.items():
        setattr(offer, key, value)
    
    db.add(offer)
    db.commit()
    db.refresh(offer)
    
    # Create audit log
    audit_log_in = schemas.OfferAuditLogCreate(
        offer_id=offer.id,
        action="update",
        old_data=old_data,
        new_data=offer.data,
        performed_by_username=current_user.username
    )
    crud.offer_audit_log.create(db, obj_in=audit_log_in)
    
    return offer

@router.post("/{offer_id}/submit", response_model=schemas.Offer, dependencies=[Depends(can_submit_offer)])
def submit_offer(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    offer_id: int = Path(..., gt=0),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> typing.Any:
    """
    Submit an offer for approval.
    """
    offer = db.query(models.Offer).filter(
        models.Offer.id == offer_id,
        models.Offer.tenant_name == tenant.name
    ).first()
    
    if not offer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Offer with ID {offer_id} not found in tenant {tenant.name}"
        )
    
    if offer.status != models.OfferStatus.DRAFT:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Offer with ID {offer_id} is not in DRAFT status and cannot be submitted"
        )
    
    # Store old data for audit log
    old_status = offer.status
    
    # Update status to PENDING_APPROVAL
    offer.status = models.OfferStatus.SUBMITTED
    db.add(offer)
    db.commit()
    db.refresh(offer)
    
    # Create audit log
    audit_log_in = schemas.OfferAuditLogCreate(
        offer_id=offer.id,
        action="submit",
        old_data={"status": old_status},
        new_data={"status": offer.status},
        performed_by_username=current_user.username
    )
    crud.offer_audit_log.create(db, obj_in=audit_log_in)
    
    return offer

@router.post("/{offer_id}/approve", response_model=schemas.Offer, dependencies=[Depends(can_approve_reject_offer)])
def approve_offer(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    offer_id: int = Path(..., gt=0),
    current_user: models.User = Depends(deps.get_current_active_user),
) -> typing.Any:
    """
    Approve an offer.
    """
    offer = db.query(models.Offer).filter(
        models.Offer.id == offer_id,
        models.Offer.tenant_name == tenant.name
    ).first()
    
    if not offer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Offer with ID {offer_id} not found in tenant {tenant.name}"
        )
    
    if offer.status != models.OfferStatus.SUBMITTED:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Offer with ID {offer_id} is not in SUBMITTED status and cannot be approved"
        )
    
    # Store old data for audit log
    old_status = offer.status
    
    # Update status to APPROVED
    offer.status = models.OfferStatus.APPROVED
    db.add(offer)
    db.commit()
    db.refresh(offer)
    
    # Create audit log
    audit_log_in = schemas.OfferAuditLogCreate(
        offer_id=offer.id,
        action="approve",
        old_data={"status": old_status},
        new_data={"status": offer.status},
        performed_by_username=current_user.username
    )
    crud.offer_audit_log.create(db, obj_in=audit_log_in)
    
    return offer

@router.post("/{offer_id}/reject", response_model=schemas.Offer, dependencies=[Depends(can_approve_reject_offer)])
def reject_offer(
    *,
    db: Session = Depends(deps.get_db),
    tenant: models.Tenant = Depends(deps.get_tenant_by_name),
    offer_id: int = Path(..., gt=0),
    rejection_data: dict,
    current_user: models.User = Depends(deps.get_current_active_user),
) -> typing.Any:
    """
    Reject an offer.
    """
    offer = db.query(models.Offer).filter(
        models.Offer.id == offer_id,
        models.Offer.tenant_name == tenant.name
    ).first()
    
    if not offer:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Offer with ID {offer_id} not found in tenant {tenant.name}"
        )
    
    if offer.status != models.OfferStatus.SUBMITTED:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Offer with ID {offer_id} is not in SUBMITTED status and cannot be rejected"
        )
    
    # Store old data for audit log
    old_status = offer.status
    
    # Update status to REJECTED and add rejection reason to comments
    offer.status = models.OfferStatus.REJECTED
    offer.comments = f"Rejected: {rejection_data.get('rejection_reason', 'No reason provided')}"
    db.add(offer)
    db.commit()
    db.refresh(offer)
    
    # Create audit log
    audit_log_in = schemas.OfferAuditLogCreate(
        offer_id=offer.id,
        action="reject",
        old_data={"status": old_status},
        new_data={"status": offer.status, "rejection_reason": rejection_data.get('rejection_reason')},
        performed_by_username=current_user.username
    )
    crud.offer_audit_log.create(db, obj_in=audit_log_in)
    
    return offer

# Add other offer endpoints (GET {id}, PUT {id}, DELETE {id}, /submit, /approve, /reject, /comment, /audit-logs)
# Each with appropriate role checks using Depends(TenantRoleChecker(...))
